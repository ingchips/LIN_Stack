# LIN_Stack

# 版权声明
  * 该仓库内的代码对所有用户开放；
  * 该仓库内的代码版权归INGCHIPS所有；
  * 该仓库内的代码不保证没有问题，请测试后使用；
  * 该仓库内的代码遵循MIT协议，详情见LICENSE，同时补充如下条款：
    * 此代码仅作为参考使用，如果任何组织或个人在使用此仓库的代码时造成了任意损失，不作为主张索赔权利的依据；
    * 如果不接受上面这一点儿，请不要使用该仓库的代码。
  * 此仓库代码由INGCHIPS员工进行维护；

# 仓库文件介绍
  * 本仓库的代码不再需要额外下载SDK包，这里已经包含了SDK上的必要文件；
  * 其中 BACKUP 文件夹内有完整的不同版本的LIN驱动包，其含义如压缩包命名所示，它对不同版本的 【ING918XX_SDK_SOURCE文件夹、LIN文件夹、VERSION.md】压缩而来；
  * 其中 ING918XX_SDK_SOURCE 文件夹内为SDK必要文件，内含SDK版本说明，与官方发布的对应版本的SDK是一样的；需要下载的协议栈也在这里面；
  * 其中 LIN文件夹内 LIN的驱动、协议栈、以及相应例程；详见下方解释：
    * 该仓库包含ING918X和ING916X开发板上的lin例程，文件夹说明：
    * lin_driver_example ： lin驱动测试的例程，或者叫物理层测试的例程；代码开源，源代码在src中；
      * lin_driver_master ： lin驱动的主节点例程，内含使用说明文档；
      * lin_driver_slave  ： lin驱动的从节点例程，内含使用说明文档；
    * lin_stack_example  ： lin协议栈测试例程，基于src中的驱动开发，其中驱动部分开源，协议栈部分以库的形式提供；
      * lin_stack_master ： lin协议栈的主节点例程，内含使用说明文档；
      * lin_stack_slave  ： lin协议栈的从节点例程，内含使用说明文档；
    * src ：提供了lin驱动部分的开源代码和lin协议栈使用的lib库，以及平台补充相关代码等：
      * lin_drv ： lin驱动源码；
      * lin_stack_lib ： lin协议栈库，以及头文件；
      * platform_supplement ： 平台补充代码；即与芯片平台相关，但是官方SDK不够全面的部分的代码；

# 如何使用该仓库的例程
  * 使用 BACKUP 文件夹 中最新的压缩包放到硬盘合适位置解压；
  * 然后下载对应协议栈到开发板，例如通过downloader下载：
    * ING918:下载 .\ING918XX_SDK_SOURCE\bundles\typical\ING9187xx\中的 platform.bin，起始地址0x4000， 或者直接下载platform.hex文件；
    * ING916:下载 .\ING918XX_SDK_SOURCE\bundles\typical\ING9168xx\中的 platform.bin，起始地址0x2002000， 或者直接下载platform.hex文件；
  * 然后下载应用程序到开发板即可，可以用keil直接下载，也可以根据keil的IROM1起始地址用downloader下载；
  * 之后就可以进行测试了；


# 功能介绍
  * 每个例程详细的功能介绍，请详细阅读对应例程下的readme.md文档；


# 关于硬件
  * 如果是ING918平台，至少需要两块开发板，这里我测试使用的开发板为ING91881B开发板 __V2 ing02-02-05__ ，这是底板和核心板一体的开发板，是早期使用的开发板；
  * 如果是ING916平台，至少需要两块开发板，这里测试使用的开发板为ING9168X开发板 __DB72C8K1A底板__ + __DB682CC1A核心板__ ，两个板子需要用杜邦线连接，而不是直接连接，因为要使用中间的引脚IO15；
  * 无论使用哪个平台的芯片，每个开发板要外扩一个lin转换器，我这里使用的为 __TJA1021转换板__ 芯片的转换板，至少要将此转换板的UART_RX，UART_TX，GND与开发板连接，同时转换板要进行12V供电，且我的转换板是自带12V转3.3V降压的，所以转换板的IO电平是3.3V的；关于开发板上使用的UART_RX，UART_TX的具体引脚值，ING918与ING916是不同的，需要参考例程里面的说明文档找到具体引脚值；
  * 特别说明：我这里使用开发板的目的是为了使用开发板上的RGB灯和按键等，如果客户有自己的板子，可自行修改软件适配，主要关心的是RGB灯、按键、串口引脚相关的移植；强烈建议先在我们的开发板上调通后再去客户自己的板子上使用，这样可以在遇到问题时有个对比，方便更快速的排查问题。
  * 适配其它硬件需要进行驱动适配：
    * __按键__: 为两个按键分配GPIO，宏定义为：USER_BUTTON_2 和 USER_BUTTON_3 ， 详见lin_user_def.h文件；
    * __串口__: lin通讯主要使用UART1，为其TX和RX分配GPIO，宏定义为：LIN1_UART_IO_TX 和 LIN1_UART_IO_RX ，详见lin_user_def.h文件；
    * __指示灯__: 根据选择灯类型不同，配置不同，最终将set_rgb_led_color调用的地方替换成自己的灯即可；


# 关于lin使用的外设资源
  * lin的驱动例程会用到一些外设资源，这里会介绍一下；
  * lin的协议栈例程是基于lin的驱动来实现的，所以，lin协议栈使用的外设资源和lin驱动使用的外设资源基本是一样的，所以这里就不做区分；
  * lin使用的外设资源与平台无关，在ING918和ING916上都是一样的，所以这里也不做区分；
  * lin的主节点使用的外设资源和lin的从节点使用的外设资源可能会因为功能不同而稍有不同，后续介绍；
  * lin使用的外设资源（不包含调试外设）：
    * 两个 __按键__ USER_BUTTON_2 和 USER_BUTTON_3 ，按键便于用户触发某些行为；根据例子类型和角色不同，功能不同，详情见例子功能说明；
    * 一个 __定时器__ APB_TMR1，定时器1，用于lin收发数据过程中的超时判断，以及纳秒时间的获取，目前有意义的功能只有超时判断，纳秒时间获取是为后续新功能开发使用的；
    * 一个 __串口__ UART1，用于配合串口中断进行lin数据通讯；其中UART1_RX引脚也作为普通GPIO，产生IO中断检测唤醒型号用；
    * 一个 __RGB三色灯__ ，用于指示通讯成功/失败；RGB灯的介绍详见下方：关于RGB灯；
    * 每个外设对应的GPIO配置详见：lin_user_def.h文件
  * 其它外设资源：
    * 一个 __调试串口__ ， UART0，用于打印调试信息；
    * 一个 __SWD接口__ ， 用于仿真和RTT打印调试信息；



# 关于RGB灯
  * lin的所有例程中均使用了RGB灯进行通讯指示，所以这里对RGB灯的使用进行汇总说明；
  * RGB灯，顾名思义就是红黄蓝三种颜色的灯，这里只是用这三种颜色的单色来使用的，没有进行混合使用；
  * 对于ING918和ING916，因为使用的开发板不同，所以某些配置不同，后续会分别介绍；
  * 桃芯平台使用RGB灯的基本软件步骤：
    * 首先，在工程中引入board.c文件；
    * 然后，在工程的Option for Target设置中的C/C++(AC6)中的Define中增加RGB宏定义：BOARD_USE_RGB_LED，另外，BOARD_ID要根据情况添加，后续分别介绍；
    * 最后，就可以在程序中使用RGB的相关函数了：
      * 首先，使用setup_rgb_led(); 进行初始化；
      * 然后，在程序中使用 set_rgb_led_color(r, g, b); 进行三色灯的控制即可，其中r，g，b三个参数的值越大，对应的灯越亮，设为0则灭；
  * 下面详细介绍不同开发板上RGB灯的个性化配置：
    * 对于ING918的开发板 V2 ing02-02-05，RGB灯的驱动芯片（位号U4）有两种，所以要自行核对一下芯片型号，不同型号的芯片，对应的BOARD_ID的宏定义的值不同，分别为：
      * WS2811芯片：BOARD_ID=BOARD_ING91881B_02_02_06
      * 59731芯片： BOARD_ID=BOARD_ING91881B_02_02_05
      * 我的开发板是用的59731的芯片，所以默认BOARD_ID=BOARD_ING91881B_02_02_05，如果你和我使用了一样的开发板，但是发现灯不亮，可修改BOARD_ID到另外一个值试一下；
    * 对于ING916的开发板 __DB72C8K1A__ 底板+ __DB682CC1A__ 核心板，BOARD_ID的宏定义如下：
      * BOARD_ID=BOARD_DB72C8K1A


# 关于DEBUG调试：
  * 这里讲述打印日志进行调试的两种手段，__串口调试__ 或 __RTT调试__ 。当然，某些场景下，用JLINK仿真调试更高效；
## 相关宏定义
  * #define LOG_BY_UART0
  * #define LOG_BY_RTT
  * 解开哪一个宏定义则使用哪一种方式打印信息，可同时通过两种方式打印。
## RTT调试：
  * 无需修改代码，连接jlink后，打开J-link RTT viewer工具，然后在弹出的configuration界面依次进行如下配置：
    * Connection to J-Link 选择：USB
    * Specify Target Device选择：ING9188XX 或者 CORTEX-M3 (如果是ING916X芯片则选择ING9168XX或M4)
    * Target Interface & Speed 选择：SWD， 速率 4000 KHZ即可；
    * RTT Control Block 选择：Search Range ，然后下面填入：0x20007000 0x4000 ，这里是告诉上位机按照 0x20007000 ~ (0x20007000+0x4000) 的范围从代码中查找 _SEGGER_RTT 的位置，所以请确保你的代码编译后，_SEGGER_RTT在该范围内；从代码中查看 _SEGGER_RTT 的方法为：编译代码，然后双击工程中project栏里的Target 1文件夹所在位置，会自动打开map文件，然后搜索“_SEGGER_RTT          ”，注意_SEGGER_RTT后面有10个空格，这样可以确保搜索值唯一，之后就可以看到它的实际地址了。
  * 配置好点击OK即可，如果电脑上只插入了一个jlink，则直接进入主界面了；
  * 之后就会显示程序中打印的LOG日志了；
## 串口调试（默认）：
  * 串口调试需要修改代码，需要将 cb_putc 函数中的 SEGGER_RTT_Write(0,c,1); 代码屏蔽掉，然后用如下两行代码替换：
    * while (apUART_Check_TXFIFO_FULL(APB_UART0) == 1);
    * UART_SendData(APB_UART0, (uint8_t)*c);
  * 即通过串口0将printf/platform_printf产生的调试数据通过串口打印出来；
  * 串口0的初始化见：setup_peripherals 函数，默认波特率为 115200bps，UART0_TXD=GPIO2, UART0_RXD=GPIO3, 可根据具体硬件进行调整；
  * 这里需要特别注意一点儿：当串口0的波特率为921600bps时，使用ING91881B的开发板打印日志，会因为jlink虚拟串口速率不够快，导致打印日志概率性丢失问题，将串口0的波特率切换为115200bps时，则此问题消失，但由于速率下降，其延迟导致的程序延时则不容忽视。例如，当我们在调试lin驱动时，如果在串口中断中使用了printf，则会根据输出方式（RTT,UART0=921600,UART0=115200等）的不同，会产生不同程度的延迟，则可能造成lin时序与实际情况不符，所以最好不要这样用，此种场景，建议仿真调试；
